<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<!-- ****************************************************** -->
<!--            Standard wxWidgets header                   -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8"/>
    <title>wxWidgets: Events and Event Handling</title>
    <meta name="author" content="wxWidgets team"/>
    <meta name="created" content="Fri Sep 4 06:57:19 2009"/>
    <meta name="keywords" content="wxWidgets"/>
    <link href="wxwidgets.css" rel="stylesheet" type="text/css"/>
    <link href="tabs.css" rel="stylesheet" type="text/css"/>
</head>
<body>


<!--          End of wxWidgets standard header           -->
<!-- *************************************************** -->

<!-- Generated by Doxygen 1.5.8 -->
<script type="text/javascript">
<!--
function changeDisplayState (e){
  var num=this.id.replace(/[^[0-9]/g,'');
  var button=this.firstChild;
  var sectionDiv=document.getElementById('dynsection'+num);
  if (sectionDiv.style.display=='none'||sectionDiv.style.display==''){
    sectionDiv.style.display='block';
    button.src='open.gif';
  }else{
    sectionDiv.style.display='none';
    button.src='closed.gif';
  }
}
function initDynSections(){
  var divs=document.getElementsByTagName('div');
  var sectionCounter=1;
  for(var i=0;i<divs.length-1;i++){
    if(divs[i].className=='dynheader'&&divs[i+1].className=='dynsection'){
      var header=divs[i];
      var section=divs[i+1];
      var button=header.firstChild;
      if (button!='IMG'){
        divs[i].insertBefore(document.createTextNode(' '),divs[i].firstChild);
        button=document.createElement('img');
        divs[i].insertBefore(button,divs[i].firstChild);
      }
      header.style.cursor='pointer';
      header.onclick=changeDisplayState;
      header.id='dynheader'+sectionCounter;
      button.src='closed.gif';
      section.id='dynsection'+sectionCounter;
      section.style.display='none';
      section.style.marginLeft='14px';
      sectionCounter++;
    }
  }
}
window.onload = initDynSections;
-->
</script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Categories</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    <li>
      <form action="search.php" method="get">
        <table cellspacing="0" cellpadding="0" border="0">
          <tr>
            <td><label>&nbsp;<u>S</u>earch&nbsp;for&nbsp;</label></td>
            <td><input type="text" name="query" value="" size="20" accesskey="s"/></td>
          </tr>
        </table>
      </form>
    </li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="index.html">Reference manual</a>&nbsp;&raquo&nbsp;<a class="el" href="page_topics.html">Topic Overviews</a>
  </div>
</div>
<div class="contents">
<h1><a class="anchor" name="overview_events">Events and Event Handling </a></h1>Related classes: <a class="el" href="classwx_evt_handler.html" title="A class that can handle events from the windowing system.">wxEvtHandler</a>, <a class="el" href="classwx_window.html" title="wxWindow is the base class for all windows and represents any visible object om screen...">wxWindow</a>, <a class="el" href="classwx_event.html" title="An event is a structure holding information about an event passed to a callback or...">wxEvent</a><p>
<ul>
<li><a class="el" href="overview_events.html#overview_events_introduction">Introduction to Events</a> </li>
<li><a class="el" href="overview_events.html#overview_events_eventhandling">Event Handling</a> </li>
<li><a class="el" href="overview_events.html#overview_events_processing">How Events are Processed</a> </li>
<li><a class="el" href="overview_events.html#overview_events_custom">Custom Event Summary</a> </li>
<li><a class="el" href="overview_events.html#overview_events_misc">Miscellaneous Notes</a></li>
</ul>
<hr>
<h2><a class="anchor" name="overview_events_introduction">
Introduction to Events</a></h2>
Like with all the other GUI frameworks, the control of flow in wxWidgets applications is event-based: the program normally performs most of its actions in response to the events generated by the user. These events can be triggered by using the input devices (such as keyboard, mouse, joystick) directly or, more commonly, by a standard control which synthesizes such input events into higher level events: for example, a <a class="el" href="classwx_button.html" title="A button is a control that contains a text string, and is one of the most common...">wxButton</a> can generate a click event when the user presses the left mouse button on it and then releases it without pressing <code>Esc</code> in the meanwhile. There are also events which don't directly correspond to the user actions, such as <a class="el" href="classwx_timer_event.html" title="wxTimerEvent object is passed to the event handler of timer events (see wxTimer::SetOwner)...">wxTimerEvent</a> or <a class="el" href="classwx_socket_event.html" title="This event class contains information about socket events.">wxSocketEvent</a>.<p>
But in all cases wxWidgets represents these events in a uniform way and allows you to handle them in the same way wherever they originate from. And while the events are normally generated by wxWidgets itself, you can also do this, which is especially useful when using custom events (see <a class="el" href="overview_events.html#overview_events_custom">Custom Event Summary</a>).<p>
To be more precise, each event is described by:<ul>
<li><em>Event type</em>: this is simply a value of type wxEventType which uniquely identifies the type of the event. For example, clicking on a button, selecting an item from a list box and pressing a key on the keyboard all generate events with different event types.</li><li><em>Event class</em> carried by the event: each event has some information associated with it and this data is represented by an object of a class derived from <a class="el" href="classwx_event.html" title="An event is a structure holding information about an event passed to a callback or...">wxEvent</a>. Events of different types can use the same event class, for example both button click and listbox selection events use <a class="el" href="classwx_command_event.html" title="This event class contains information about command events, which originate from...">wxCommandEvent</a> class (as do all the other simple control events), but the key press event uses <a class="el" href="classwx_key_event.html" title="This event class contains information about keypress (character) events.">wxKeyEvent</a> as the information associated with it is different.</li><li><em>Event source</em>: <a class="el" href="classwx_event.html" title="An event is a structure holding information about an event passed to a callback or...">wxEvent</a> stores the object which generated the event and, for windows, its identifier (see <a class="el" href="overview_events.html#overview_events_winid">Window Identifiers</a>). As it is common to have more than one object generating events of the same type (e.g. a typical window contains several buttons, all generating the same button click event), checking the event source object or its id allows to distinguish between them.</li></ul>
<h2><a class="anchor" name="overview_events_eventhandling">
Event Handling</a></h2>
There are two principal ways to handle events in wxWidgets. One of them uses <em>event table</em> macros and allows you to define the binding between events and their handlers only statically, i.e., during program compilation. The other one uses <a class="el" href="classwx_evt_handler.html#84b1e446053bda8f76f13336839e8b64" title="Binds the given function, functor or method dynamically with the event.">wxEvtHandler::Bind&lt;&gt;()</a> call and can be used to bind and unbind, the handlers dynamically, i.e. during run-time depending on some conditions. It also allows the direct binding of events to: <ul>
<li>A handler method in another object. </li>
<li>An ordinary function like a static method or a global function. </li>
<li>An arbitrary functor like boost::function&lt;&gt;.</li>
</ul>
The static event tables can only handle events in the object where they are defined so using Bind&lt;&gt;() is more flexible than using the event tables. On the other hand, event tables are more succinct and centralize all event handler bindings in one place. You can either choose a single approach that you find preferable or freely combine both methods in your program in different classes or even in one and the same class, although this is probably sufficiently confusing to be a bad idea.<p>
Also notice that most of the existing wxWidgets tutorials and discussions use the event tables because they historically preceded the apparition of dynamic event handling in wxWidgets. But this absolutely doesn't mean that using the event tables is the preferred way: handling events dynamically is better in several aspects and you should strongly consider doing it if you are just starting with wxWidgets. On the other hand, you still need to know about the event tables if only because you are going to see them in many samples and examples.<p>
So before you make the choice between static event tables and dynamically connecting the event handlers, let us discuss these two ways in more detail. In the next section we provide a short introduction to handling the events using the event tables. Please see <a class="el" href="overview_events.html#overview_events_bind">Dynamic Event Handling</a> for the discussion of Bind&lt;&gt;().<h3><a class="anchor" name="overview_events_eventtables">
Event Handling with Event Tables</a></h3>
To use an <em>event table</em> you must first decide in which class you wish to handle the events. The only requirement imposed by wxWidgets is that this class must derive from <a class="el" href="classwx_evt_handler.html" title="A class that can handle events from the windowing system.">wxEvtHandler</a> and so, considering that <a class="el" href="classwx_window.html" title="wxWindow is the base class for all windows and represents any visible object om screen...">wxWindow</a> derives from it, any classes representing windows can handle events. Simple events such as menu commands are usually processed at the level of a top-level window containing the menu, so let's suppose that you need to handle some events in <code>MyFrame</code> class deriving from <a class="el" href="classwx_frame.html" title="A frame is a window whose size and position can (usually) be changed by the user...">wxFrame</a>.<p>
First define one or more <em>event handlers</em>. They are just simple methods of the class that take as a parameter a reference to an object of a wxEvent-derived class and have no return value (any return information is passed via the argument, which is why it is non-const). You also need to insert a macro<p>
<div class="fragment"><pre class="fragment"><a class="code" href="group__group__funcmacro__events.html#g7c5c2ed4b4fcd9644d6f21c824721adf" title="Use this macro inside a class declaration to declare a static event table for that...">DECLARE_EVENT_TABLE</a>()
</pre></div><p>
somewhere in the class declaration. It doesn't matter where it appears but it's customary to put it at the end because the macro changes the access type internally so it's safest if nothing follows it. The full class declaration might look like this:<p>
<div class="fragment"><pre class="fragment"><span class="keyword">class </span>MyFrame : <span class="keyword">public</span> <a class="code" href="classwx_frame.html" title="A frame is a window whose size and position can (usually) be changed by the user...">wxFrame</a>
{
<span class="keyword">public</span>:
    MyFrame(...) : <a class="code" href="classwx_frame.html" title="A frame is a window whose size and position can (usually) be changed by the user...">wxFrame</a>(...) { }

    ...

protected:
    <span class="keywordtype">int</span> m_whatever;

<span class="keyword">private</span>:
    <span class="comment">// Notice that as the event handlers normally are not called from outside</span>
    <span class="comment">// the class, they normally are private. In particular they don't need</span>
    <span class="comment">// to be public.</span>
    <span class="keywordtype">void</span> OnExit(<a class="code" href="classwx_command_event.html" title="This event class contains information about command events, which originate from...">wxCommandEvent</a>&amp; event);
    <span class="keywordtype">void</span> OnButton1(<a class="code" href="classwx_command_event.html" title="This event class contains information about command events, which originate from...">wxCommandEvent</a>&amp; event);
    <span class="keywordtype">void</span> OnSize(<a class="code" href="classwx_size_event.html" title="A size event holds information about size change events of wxWindow.">wxSizeEvent</a>&amp; event);

    <span class="comment">// it's common to call the event handlers OnSomething() but there is no</span>
    <span class="comment">// obligation to do that; this one is an event handler too:</span>
    <span class="keywordtype">void</span> DoTest(<a class="code" href="classwx_command_event.html" title="This event class contains information about command events, which originate from...">wxCommandEvent</a>&amp; event);

    <a class="code" href="group__group__funcmacro__events.html#g7c5c2ed4b4fcd9644d6f21c824721adf" title="Use this macro inside a class declaration to declare a static event table for that...">DECLARE_EVENT_TABLE</a>()
};
</pre></div><p>
Next the event table must be defined and, as with any definition, it must be placed in an implementation file. The event table tells wxWidgets how to map events to member functions and in our example it could look like this:<p>
<div class="fragment"><pre class="fragment"><a class="code" href="group__group__funcmacro__events.html#g405678e40da45711c720b72cda7f1470" title="Use this macro in a source file to start listing static event handlers for a specific...">BEGIN_EVENT_TABLE</a>(MyFrame, <a class="code" href="classwx_frame.html" title="A frame is a window whose size and position can (usually) be changed by the user...">wxFrame</a>)
    EVT_MENU(<a class="code" href="defs_8h.html#c66d0a09761e7d86b2ac0b2e0c6a8cbb37f548d1211c664ede962e943baad4e5">wxID_EXIT</a>, MyFrame::OnExit)
    EVT_MENU(DO_TEST, MyFrame::DoTest)
    EVT_SIZE(MyFrame::OnSize)
    EVT_BUTTON(BUTTON1, MyFrame::OnButton1)
<a class="code" href="group__group__funcmacro__events.html#g5df87bbe7c82edea87b2aeaa6dc57cfd" title="Use this macro in a source file to end listing static event handlers for a specific...">END_EVENT_TABLE</a>()
</pre></div><p>
Notice that you must mention a method you want to use for the event handling in the event table definition; just defining it in MyFrame class is <em>not</em> enough.<p>
Let us now look at the details of this definition: the first line means that we are defining the event table for MyFrame class and that its base class is <a class="el" href="classwx_frame.html" title="A frame is a window whose size and position can (usually) be changed by the user...">wxFrame</a>, so events not processed by MyFrame will, by default, be handled by <a class="el" href="classwx_frame.html" title="A frame is a window whose size and position can (usually) be changed by the user...">wxFrame</a>. The next four lines define bindings of individual events to their handlers: the first two of them map menu commands from the items with the identifiers specified as the first macro parameter to two different member functions. In the next one, <code>EVT_SIZE</code> means that any changes in the size of the frame will result in calling OnSize() method. Note that this macro doesn't need a window identifier, since normally you are only interested in the current window's size events.<p>
The <code>EVT_BUTTON</code> macro demonstrates that the originating event does not have to come from the window class implementing the event table -- if the event source is a button within a panel within a frame, this will still work, because event tables are searched up through the hierarchy of windows for the command events. (But only command events, so you can't catch mouse move events in a child control in the parent window in the same way because <a class="el" href="classwx_mouse_event.html" title="This event class contains information about the events generated by the mouse: they...">wxMouseEvent</a> doesn't derive from <a class="el" href="classwx_command_event.html" title="This event class contains information about command events, which originate from...">wxCommandEvent</a>. See below for how you can do it.) In this case, the button's event table will be searched, then the parent panel's, then the frame's.<p>
Finally, you need to implement the event handlers. As mentioned before, all event handlers take a wxEvent-derived argument whose exact class differs according to the type of event and the class of the originating window. For size events, <a class="el" href="classwx_size_event.html" title="A size event holds information about size change events of wxWindow.">wxSizeEvent</a> is used. For menu commands and most control commands (such as button presses), <a class="el" href="classwx_command_event.html" title="This event class contains information about command events, which originate from...">wxCommandEvent</a> is used. When controls get more complicated, more specific wxCommandEvent-derived event classes providing additional control-specific information can be used, such as <a class="el" href="classwx_tree_event.html" title="A tree event holds information about events associated with wxTreeCtrl objects.">wxTreeEvent</a> for events from <a class="el" href="classwx_tree_ctrl.html" title="A tree control presents information as a hierarchy, with items that may be expanded...">wxTreeCtrl</a> windows.<p>
In the simplest possible case an event handler may not use the <code>event</code> parameter at all. For example,<p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">void</span> MyFrame::OnExit(<a class="code" href="classwx_command_event.html" title="This event class contains information about command events, which originate from...">wxCommandEvent</a>&amp; WXUNUSED(event))
{
    <span class="comment">// when the user selects "Exit" from the menu we should close</span>
    Close(<span class="keyword">true</span>);
}
</pre></div><p>
In other cases you may need some information carried by the <code>event</code> argument, as in:<p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">void</span> MyFrame::OnSize(<a class="code" href="classwx_size_event.html" title="A size event holds information about size change events of wxWindow.">wxSizeEvent</a>&amp; event)
{
    <a class="code" href="classwx_size.html" title="A wxSize is a useful data structure for graphics operations.">wxSize</a> size = <span class="keyword">event</span>.GetSize();

    ... update the frame <span class="keyword">using</span> the <span class="keyword">new</span> size ...
}
</pre></div><p>
You will find the details about the event table macros and the corresponding wxEvent-derived classes in the discussion of each control generating these events.<h3><a class="anchor" name="overview_events_bind">
Dynamic Event Handling</a></h3>
The possibilities of handling events in this way are rather different. Let us start by looking at the syntax: the first obvious difference is that you need not use <a class="el" href="group__group__funcmacro__events.html#g7c5c2ed4b4fcd9644d6f21c824721adf" title="Use this macro inside a class declaration to declare a static event table for that...">DECLARE_EVENT_TABLE()</a> nor <a class="el" href="group__group__funcmacro__events.html#g405678e40da45711c720b72cda7f1470" title="Use this macro in a source file to start listing static event handlers for a specific...">BEGIN_EVENT_TABLE()</a> and the associated macros. Instead, in any place in your code, but usually in the code of the class defining the handler itself (and definitely not in the global scope as with the event tables), call its Bind&lt;&gt;() method like this:<p>
<div class="fragment"><pre class="fragment">MyFrame::MyFrame(...)
{
      Bind(wxEVT_COMMAND_MENU_SELECTED, &amp;MyFrame::OnExit, <span class="keyword">this</span>, wxID_EXIT);
}
</pre></div><p>
Note that <code>this</code> pointer must be specified here.<p>
Now let us describe the semantic differences: <ul>
<li>
Event handlers can be bound at any moment. For example, it's possible to do some initialization first and only bind the handlers if and when it succeeds. This can avoid the need to test that the object was properly initialized in the event handlers themselves. With Bind&lt;&gt;() they simply won't be called if it wasn't correctly initialized. <p>
</li>
<li>
As a slight extension of the above, the handlers can also be unbound at any time with Unbind&lt;&gt;() (and maybe rebound later). Of course, it's also possible to emulate this behaviour with the classic static (i.e., bound via event tables) handlers by using an internal flag indicating whether the handler is currently enabled and returning from it if it isn't, but using dynamically bind handlers requires less code and is also usually more clear. <p>
</li>
<li>
Almost last but very, very far from least is the increased flexibility which allows to bind an event to: <ul>
<li>A method in another object. </li>
<li>An ordinary function like a static method or a global function. </li>
<li>An arbitrary functor like boost::function&lt;&gt;.</li>
</ul>
This is impossible to do with the event tables because it is not possible to specify these handlers to dispatch the event to, so it necessarily needs to be sent to the same object which generated the event. Not so with Bind&lt;&gt;() which can be used to specify these handlers which will handle the event. To give a quick example, a common question is how to receive the mouse movement events happening when the mouse is in one of the frame children in the frame itself. Doing it in a naive way doesn't work: <ul>
<li>
A <code>EVT_LEAVE_WINDOW(MyFrame::OnMouseLeave)</code> line in the frame event table has no effect as mouse move (including entering and leaving) events are not propagated up to the parent window (at least not by default). <p>
</li>
<li>
Putting the same line in a child event table will crash during run-time because the MyFrame method will be called on a wrong object -- it's easy to convince oneself that the only object that can be used here is the pointer to the child, as wxWidgets has nothing else. But calling a frame method with the child window pointer instead of the pointer to the frame is, of course, disastrous.  </li>
</ul>
<p>
However writing <div class="fragment"><pre class="fragment">            MyFrame::MyFrame(...)
            {
              m_child-&gt;Bind(wxEVT_LEAVE_WINDOW, &amp;MyFrame::OnMouseLeave, <span class="keyword">this</span>);
            }
</pre></div> will work exactly as expected. Note that you can get the object that generated the event -- and that is not the same as the frame -- via <a class="el" href="classwx_event.html#bdc74e95c8c2f32f2cc2bd84b88985ee" title="Returns the object (usually a window) associated with the event, if any.">wxEvent::GetEventObject()</a> method of <code>event</code> argument passed to the event handler. <p>
</li>
<li>
Really last point is the consequence of the previous one: because of increased flexibility of Bind(), it is also safer as it is impossible to accidentally use a method of another class. Instead of run-time crashes you will get compilation errors in this case when using Bind().  </li>
</ul>
<p>
Let us now look at more examples of how to use different event handlers using the two overloads of Bind() function: first one for the object methods and the other one for arbitrary functors (callable objects, including simple functions):<p>
In addition to using a method of the object generating the event itself, you can use a method from a completely different object as an event handler:<p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">void</span> MyFrameHandler::OnFrameExit( <a class="code" href="classwx_command_event.html" title="This event class contains information about command events, which originate from...">wxCommandEvent</a> &amp; )
{
    <span class="comment">// Do something useful.</span>
}

MyFrameHandler myFrameHandler;

MyFrame::MyFrame()
{
      Bind( wxEVT_COMMAND_MENU_SELECTED, &amp;MyFrameHandler::OnFrameExit,
              &amp;myFrameHandler, wxID_EXIT );
}
</pre></div><p>
Note that <code>MyFrameHandler</code> doesn't need to derive from <a class="el" href="classwx_evt_handler.html" title="A class that can handle events from the windowing system.">wxEvtHandler</a>. But keep in mind that then the lifetime of <code>myFrameHandler</code> must be greater than that of <code>MyFrame</code> object -- or at least it needs to be unbound before being destroyed.<p>
To use an ordinary function or a static method as an event handler you would write something like this:<p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">void</span> HandleExit( <a class="code" href="classwx_command_event.html" title="This event class contains information about command events, which originate from...">wxCommandEvent</a> &amp; )
{
    <span class="comment">// Do something useful</span>
}

MyFrame::MyFrame()
{
    Bind( wxEVT_COMMAND_MENU_SELECTED, &amp;HandleExit, wxID_EXIT );
}
</pre></div><p>
And finally you can bind to an arbitrary functor and use it as an event handler:<p>
<div class="fragment"><pre class="fragment"><span class="keyword">struct </span>MyFunctor
{
    <span class="keywordtype">void</span> operator()( <a class="code" href="classwx_command_event.html" title="This event class contains information about command events, which originate from...">wxCommandEvent</a> &amp; )
    {
        <span class="comment">// Do something useful</span>
    }
};

MyFunctor myFunctor;

MyFrame::MyFrame()
{
    Bind( wxEVT_COMMAND_MENU_SELECTED, &amp;myFunctor, wxID_EXIT );
}
</pre></div><p>
A common example of a functor is boost::function&lt;&gt;:<p>
<div class="fragment"><pre class="fragment"><span class="keyword">using namespace </span>boost;

<span class="keywordtype">void</span> MyHandler::OnExit( <a class="code" href="classwx_command_event.html" title="This event class contains information about command events, which originate from...">wxCommandEvent</a> &amp; )
{
    <span class="comment">// Do something useful</span>
}

MyHandler myHandler;

MyFrame::MyFrame()
{
    function&lt; void ( wxCommandEvent &amp; ) &gt; exitHandler( bind( &amp;MyHandler::OnExit, &amp;myHandler, _1 ));

    Bind( wxEVT_COMMAND_MENU_SELECTED, exitHandler, wxID_EXIT );
}
</pre></div><p>
With the aid of boost::bind&lt;&gt;() you can even use methods or functions which don't quite have the correct signature:<p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">void</span> MyHandler::OnExit( <span class="keywordtype">int</span> exitCode, <a class="code" href="classwx_command_event.html" title="This event class contains information about command events, which originate from...">wxCommandEvent</a> &amp;, <a class="code" href="classwx_string.html" title="The wxString class has been completely rewritten for wxWidgets 3.0 and this change...">wxString</a> goodByeMessage )
{
    <span class="comment">// Do something useful</span>
}

MyHandler myHandler;

MyFrame::MyFrame()
{
    function&lt; void ( wxCommandEvent &amp; ) &gt; exitHandler(
            bind( &amp;MyHandler::OnExit, &amp;myHandler, EXIT_FAILURE, _1, <span class="stringliteral">"Bye"</span> ));

    Bind( wxEVT_COMMAND_MENU_SELECTED, exitHandler, wxID_EXIT );
}
</pre></div><p>
To summarize, using Bind&lt;&gt;() requires slightly more typing but is much more flexible than using static event tables so don't hesitate to use it when you need this extra power. On the other hand, event tables are still perfectly fine in simple situations where this extra flexibility is not needed.<h2><a class="anchor" name="overview_events_processing">
How Events are Processed</a></h2>
The previous sections explain how to define event handlers but don't address the question of how exactly wxWidgets finds the handler to call for the given event. This section describes the algorithm used in detail.<p>
When an event is received from the windowing system, wxWidgets calls <a class="el" href="classwx_evt_handler.html#65968dd27f3aac7718f2dd6b2ddd5a08" title="Processes an event, searching event tables and calling zero or more suitable event...">wxEvtHandler::ProcessEvent()</a> on the first event handler object belonging to the window generating the event. The normal order of event table searching by ProcessEvent() is as follows, with the event processing stopping as soon as a handler is found (unless the handler calls <a class="el" href="classwx_event.html#98eb20b76106f9a933c2eb3ee119f66c" title="This method can be used inside an event handler to control whether further event...">wxEvent::Skip()</a> in which case it doesn't count as having handled the event and the search continues): <ol>
<li value="0">
Before anything else happens, <a class="el" href="classwx_app_console.html#da7ab606e014a10d46e4b3c6f602e20c" title="This function is called before processing any event and allows the application to...">wxApp::FilterEvent()</a> is called. If it returns anything but -1 (default), the event handling stops immediately. <p>
</li>
<li value="1">
If this event handler is disabled via a call to <a class="el" href="classwx_evt_handler.html#7388ae19c8657e5656471b658c320036" title="Enables or disables the event handler.">wxEvtHandler::SetEvtHandlerEnabled()</a> the next three steps are skipped and the event handler resumes at step (5). <p>
</li>
<li value="2">
If the object is a <a class="el" href="classwx_window.html" title="wxWindow is the base class for all windows and represents any visible object om screen...">wxWindow</a> and has an associated validator, <a class="el" href="classwx_validator.html" title="wxValidator is the base class for a family of validator classes that mediate between...">wxValidator</a> gets a chance to process the event. <p>
</li>
<li value="3">
The list of dynamically bind event handlers, i.e., those for which Bind&lt;&gt;() was called, is consulted. Notice that this is done before checking the static event table entries, so if both a dynamic and a static event handler match the same event, the static one is never going to be used. <p>
</li>
<li value="4">
The event table containing all the handlers defined using the event table macros in this class and its base classes is examined. Notice that this means that any event handler defined in a base class will be executed at this step. <p>
</li>
<li value="5">
The event is passed to the next event handler, if any, in the event handler chain, i.e., the steps (1) to (4) are done for it. This chain can be formed using <a class="el" href="classwx_evt_handler.html#68e2ef2d2b7d68c4c9c18ca92933031b" title="Sets the pointer to the next handler.">wxEvtHandler::SetNextHandler()</a>: <div align="center">
<img src="overview_events_chain.png" alt="overview_events_chain.png">
</div>
 (referring to the image, if <code>A-&gt;ProcessEvent</code> is called and it doesn't handle the event, <code>B-&gt;ProcessEvent</code> will be called and so on...). In the case of <a class="el" href="classwx_window.html" title="wxWindow is the base class for all windows and represents any visible object om screen...">wxWindow</a> you can build a stack (implemented using <a class="el" href="classwx_evt_handler.html" title="A class that can handle events from the windowing system.">wxEvtHandler</a> double-linked list) using <a class="el" href="classwx_window.html#398c11ab9af7956067a964f560d1978c" title="Pushes this event handler onto the event stack for the window.">wxWindow::PushEventHandler()</a>: <div align="center">
<img src="overview_events_winstack.png" alt="overview_events_winstack.png">
</div>
 (referring to the image, if <code>W-&gt;ProcessEvent</code> is called, it immediately calls <code>A-&gt;ProcessEvent</code>; if nor <code>A</code> nor <code>B</code> handle the event, then the <a class="el" href="classwx_window.html" title="wxWindow is the base class for all windows and represents any visible object om screen...">wxWindow</a> itself is used - i.e. the dynamically bind event handlers and static event table entries of <a class="el" href="classwx_window.html" title="wxWindow is the base class for all windows and represents any visible object om screen...">wxWindow</a> are looked as the last possibility, after all pushed event handlers were tested). Note however that usually there are no <a class="el" href="classwx_evt_handler.html" title="A class that can handle events from the windowing system.">wxEvtHandler</a> chains nor wxWindows stacks so this step will usually do anything. <p>
</li>
<li value="6">
If the object is a <a class="el" href="classwx_window.html" title="wxWindow is the base class for all windows and represents any visible object om screen...">wxWindow</a> and the event is set to propagate (by default only wxCommandEvent-derived events are set to propagate), then the processing restarts from the step (1) (and excluding the step (7)) for the parent window. If this object is not a window but the next handler exists, the event is passed to its parent if it is a window. This ensures that in a common case of (possibly several) non-window event handlers pushed on top of a window, the event eventually reaches the window parent. <p>
</li>
<li value="7">
Finally, i.e., if the event is still not processed, the <a class="el" href="classwx_app.html" title="The wxApp class represents the application itself when wxUSE_GUI=1.">wxApp</a> object itself (which derives from <a class="el" href="classwx_evt_handler.html" title="A class that can handle events from the windowing system.">wxEvtHandler</a>) gets a last chance to process it.  </li>
</ol>
<p>
<em>Please pay close attention to step 6!</em> People often overlook or get confused by this powerful feature of the wxWidgets event processing system. The details of event propagation up the window hierarchy are described in the next section.<p>
Also please notice that there are additional steps in the event handling for the windows-making part of wxWidgets document-view framework, i.e., <a class="el" href="classwx_doc_parent_frame.html" title="The wxDocParentFrame class provides a default top-level frame for applications using...">wxDocParentFrame</a>, <a class="el" href="classwx_doc_child_frame.html" title="The wxDocChildFrame class provides a default frame for displaying documents on separate...">wxDocChildFrame</a> and their MDI equivalents <a class="el" href="classwx_doc_m_d_i_parent_frame.html" title="The wxDocMDIParentFrame class provides a default top-level frame for applications...">wxDocMDIParentFrame</a> and <a class="el" href="classwx_doc_m_d_i_child_frame.html" title="The wxDocMDIChildFrame class provides a default frame for displaying documents on...">wxDocMDIChildFrame</a>. The parent frame classes modify step (2) above to send the events received by them to <a class="el" href="classwx_doc_manager.html" title="The wxDocManager class is part of the document/view framework supported by wxWidgets...">wxDocManager</a> object first. This object, in turn, sends the event to the current view and the view itself lets its associated document process the event first. The child frame classes send the event directly to the associated view which still forwards it to its document object. Notice that to avoid remembering the exact order in which the events are processed in the document-view frame, the simplest, and recommended, solution is to only handle the events at the view classes level, and not in the document or document manager classes<h3><a class="anchor" name="overview_events_propagation">
How Events Propagate Upwards</a></h3>
As mentioned above, the events of the classes deriving from <a class="el" href="classwx_command_event.html" title="This event class contains information about command events, which originate from...">wxCommandEvent</a> are propagated by default to the parent window if they are not processed in this window itself. But although by default only the command events are propagated like this, other events can be propagated as well because the event handling code uses <a class="el" href="classwx_event.html#d265ef226445cb6b72a2697dd9d3b406" title="Test if this event should be propagated or not, i.e.">wxEvent::ShouldPropagate()</a> to check whether an event should be propagated. It is also possible to propagate the event only a limited number of times and not until it is processed (or a top level parent window is reached).<p>
Finally, there is another additional complication (which, in fact, simplifies life of wxWidgets programmers significantly): when propagating the command events up to the parent window, the event propagation stops when it reaches the parent dialog, if any. This means that you don't risk getting unexpected events from the dialog controls (which might be left unprocessed by the dialog itself because it doesn't care about them) when a modal dialog is popped up. The events do propagate beyond the frames, however. The rationale for this choice is that there are only a few frames in a typical application and their parent-child relation are well understood by the programmer while it may be difficult, if not impossible, to track down all the dialogs that may be popped up in a complex program (remember that some are created automatically by wxWidgets). If you need to specify a different behaviour for some reason, you can use wxWindow::SetExtraStyle(wxWS_EX_BLOCK_EVENTS) explicitly to prevent the events from being propagated beyond the given window or unset this flag for the dialogs that have it on by default.<p>
Typically events that deal with a window as a window (size, motion, paint, mouse, keyboard, etc.) are sent only to the window. Events that have a higher level of meaning or are generated by the window itself (button click, menu select, tree expand, etc.) are command events and are sent up to the parent to see if it is interested in the event. More precisely, as said above, all event classes <b>not</b> deriving from <a class="el" href="classwx_command_event.html" title="This event class contains information about command events, which originate from...">wxCommandEvent</a> (see the <a class="el" href="classwx_event.html" title="An event is a structure holding information about an event passed to a callback or...">wxEvent</a> inheritance map) do <b>not</b> propagate upward.<p>
In some cases, it might be desired by the programmer to get a certain number of system events in a parent window, for example all key events sent to, but not used by, the native controls in a dialog. In this case, a special event handler will have to be written that will override ProcessEvent() in order to pass all events (or any selection of them) to the parent window.<h2><a class="anchor" name="overview_events_custom">
Custom Event Summary</a></h2>
<h3><a class="anchor" name="overview_events_custom_general">
General approach</a></h3>
As each event is uniquely defined by its event type, defining a custom event starts with defining a new event type for it. This is done using <a class="el" href="group__group__funcmacro__events.html#g09ec1d095bee3085c1cb31459b46bc00" title="Define a new event type associated with the specified event class.">wxDEFINE_EVENT()</a> macro. As an event type is a variable, it can also be declared using <a class="el" href="group__group__funcmacro__events.html#g767b12d37f7370bc5f6b3d62340f3ef8" title="Declares a custom event type.">wxDECLARE_EVENT()</a> if necessary.<p>
The next thing to do is to decide whether you need to define a custom event class for events of this type or if you can reuse an existing class, typically either <a class="el" href="classwx_event.html" title="An event is a structure holding information about an event passed to a callback or...">wxEvent</a> (which doesn't provide any extra information) or <a class="el" href="classwx_command_event.html" title="This event class contains information about command events, which originate from...">wxCommandEvent</a> (which contains several extra fields and also propagates upwards by default). Both strategies are described in details below. See also the <a class="el" href="page_samples.html#page_samples_event">Event Sample</a> for a complete example of code defining and working with the custom event types.<h3><a class="anchor" name="overview_events_custom_existing">
Using Existing Event Classes</a></h3>
If you just want to use a <a class="el" href="classwx_command_event.html" title="This event class contains information about command events, which originate from...">wxCommandEvent</a> with a new event type, use one of the generic event table macros listed below, without having to define a new event class yourself.<p>
Example:<p>
<div class="fragment"><pre class="fragment"><span class="comment">// this is typically in a header: it just declares MY_EVENT event type</span>
<a class="code" href="group__group__funcmacro__events.html#g767b12d37f7370bc5f6b3d62340f3ef8" title="Declares a custom event type.">wxDECLARE_EVENT</a>(MY_EVENT, <a class="code" href="classwx_command_event.html" title="This event class contains information about command events, which originate from...">wxCommandEvent</a>);

<span class="comment">// this is a definition so can't be in a header</span>
<a class="code" href="group__group__funcmacro__events.html#g09ec1d095bee3085c1cb31459b46bc00" title="Define a new event type associated with the specified event class.">wxDEFINE_EVENT</a>(MY_EVENT, <a class="code" href="classwx_command_event.html" title="This event class contains information about command events, which originate from...">wxCommandEvent</a>);

<span class="comment">// example of code handling the event with event tables</span>
<a class="code" href="group__group__funcmacro__events.html#g405678e40da45711c720b72cda7f1470" title="Use this macro in a source file to start listing static event handlers for a specific...">BEGIN_EVENT_TABLE</a>(MyFrame, <a class="code" href="classwx_frame.html" title="A frame is a window whose size and position can (usually) be changed by the user...">wxFrame</a>)
    EVT_MENU    (wxID_EXIT, MyFrame::OnExit)
    ...
    EVT_COMMAND (ID_MY_WINDOW, MY_EVENT, MyFrame::OnMyEvent)
<a class="code" href="group__group__funcmacro__events.html#g5df87bbe7c82edea87b2aeaa6dc57cfd" title="Use this macro in a source file to end listing static event handlers for a specific...">END_EVENT_TABLE</a>()

<span class="keywordtype">void</span> MyFrame::OnMyEvent(<a class="code" href="classwx_command_event.html" title="This event class contains information about command events, which originate from...">wxCommandEvent</a>&amp; event)
{
    <span class="comment">// do something</span>
    <a class="code" href="classwx_string.html" title="The wxString class has been completely rewritten for wxWidgets 3.0 and this change...">wxString</a> text = <span class="keyword">event</span>.GetText();
}

<span class="comment">// example of code handling the event with Bind&lt;&gt;():</span>
MyFrame::MyFrame()
{
    Bind(MY_EVENT, &amp;MyFrame::OnMyEvent, <span class="keyword">this</span>, ID_MY_WINDOW);
}

<span class="comment">// example of code generating the event</span>
<span class="keywordtype">void</span> MyWindow::SendEvent()
{
    <a class="code" href="classwx_command_event.html" title="This event class contains information about command events, which originate from...">wxCommandEvent</a> event(MY_EVENT, GetId());
    <span class="keyword">event</span>.SetEventObject(<span class="keyword">this</span>);

    <span class="comment">// Give it some contents</span>
    <span class="keyword">event</span>.SetText(<span class="stringliteral">"Hello"</span>);

    <span class="comment">// Do send it</span>
    ProcessWindowEvent(event);
}
</pre></div><h3><a class="anchor" name="overview_events_custom_ownclass">
Defining Your Own Event Class</a></h3>
Under certain circumstances, you must define your own event class e.g., for sending more complex data from one place to another. Apart from defining your event class, you also need to define your own event table macro if you want to use event tables for handling events of this type.<p>
Here is an example:<p>
<div class="fragment"><pre class="fragment"><span class="comment">// define a new event class</span>
<span class="keyword">class </span>MyPlotEvent: <span class="keyword">public</span> <a class="code" href="classwx_event.html" title="An event is a structure holding information about an event passed to a callback or...">wxEvent</a>
{
<span class="keyword">public</span>:
    MyPlotEvent(<a class="code" href="group__group__funcmacro__events.html#g6a7fd172612c0d6d9029bfa3aa91aca0" title="A value uniquely identifying the type of the event.">wxEventType</a> eventType, <span class="keywordtype">int</span> winid, <span class="keyword">const</span> <a class="code" href="classwx_point.html" title="A wxPoint is a useful data structure for graphics operations.">wxPoint</a>&amp; pos)
        : <a class="code" href="classwx_event.html" title="An event is a structure holding information about an event passed to a callback or...">wxEvent</a>(winid, eventType),
          m_pos(pos)
    {
    }

    <span class="comment">// accessors</span>
    <a class="code" href="classwx_point.html" title="A wxPoint is a useful data structure for graphics operations.">wxPoint</a> GetPoint()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> m_pos; }

    <span class="comment">// implement the base class pure virtual</span>
    <span class="keyword">virtual</span> <a class="code" href="classwx_event.html" title="An event is a structure holding information about an event passed to a callback or...">wxEvent</a> *Clone()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="keyword">new</span> MyPlotEvent(*<span class="keyword">this</span>); }

<span class="keyword">private</span>:
    <span class="keyword">const</span> <a class="code" href="classwx_point.html" title="A wxPoint is a useful data structure for graphics operations.">wxPoint</a> m_pos;
};

<span class="comment">// we define a single MY_PLOT_CLICKED event type associated with the class</span>
<span class="comment">// above but typically you are going to have more than one event type, e.g. you</span>
<span class="comment">// could also have MY_PLOT_ZOOMED or MY_PLOT_PANNED &amp;c -- in which case you</span>
<span class="comment">// would just add more similar lines here</span>
<a class="code" href="group__group__funcmacro__events.html#g09ec1d095bee3085c1cb31459b46bc00" title="Define a new event type associated with the specified event class.">wxDEFINE_EVENT</a>(MY_PLOT_CLICKED, MyPlotEvent);


<span class="comment">// if you want to support old compilers you need to use some ugly macros:</span>
<span class="keyword">typedef</span> void (<a class="code" href="classwx_evt_handler.html" title="A class that can handle events from the windowing system.">wxEvtHandler</a>::*MyPlotEventFunction)(MyPlotEvent&amp;);
<span class="preprocessor">#define MyPlotEventHandler(func) wxEVENT_HANDLER_CAST(MyPlotEventFunction, func)</span>
<span class="preprocessor"></span>
<span class="comment">// if your code is only built using reasonably modern compilers, you could just</span>
<span class="comment">// do this instead:</span>
<span class="preprocessor">#define MyPlotEventHandler(func) (&amp;func)</span>
<span class="preprocessor"></span>
<span class="comment">// finally define a macro for creating the event table entries for the new</span>
<span class="comment">// event type</span>
<span class="comment">//</span>
<span class="comment">// remember that you don't need this at all if you only use Bind&lt;&gt;() and that</span>
<span class="comment">// you can replace MyPlotEventHandler(func) with just &amp;func unless you use a</span>
<span class="comment">// really old compiler</span>
<span class="preprocessor">#define MY_EVT_PLOT_CLICK(id, func) \</span>
<span class="preprocessor">    wx__DECLARE_EVT1(MY_PLOT_CLICKED, id, MyPlotEventHandler(func))</span>
<span class="preprocessor"></span>

<span class="comment">// example of code handling the event (you will use one of these methods, not</span>
<span class="comment">// both, of course):</span>
<a class="code" href="group__group__funcmacro__events.html#g405678e40da45711c720b72cda7f1470" title="Use this macro in a source file to start listing static event handlers for a specific...">BEGIN_EVENT_TABLE</a>(MyFrame, <a class="code" href="classwx_frame.html" title="A frame is a window whose size and position can (usually) be changed by the user...">wxFrame</a>)
    EVT_PLOT(ID_MY_WINDOW, MyFrame::OnPlot)
<a class="code" href="group__group__funcmacro__events.html#g5df87bbe7c82edea87b2aeaa6dc57cfd" title="Use this macro in a source file to end listing static event handlers for a specific...">END_EVENT_TABLE</a>()

MyFrame::MyFrame()
{
    Bind(MY_PLOT_CLICKED, &amp;MyFrame::OnPlot, <span class="keyword">this</span>, ID_MY_WINDOW);
}

<span class="keywordtype">void</span> MyFrame::OnPlot(MyPlotEvent&amp; event)
{
    ... <span class="keywordflow">do</span> something with <span class="keyword">event</span>.GetPoint() ...
}


<span class="comment">// example of code generating the event:</span>
<span class="keywordtype">void</span> MyWindow::SendEvent()
{
    MyPlotEvent event(MY_PLOT_CLICKED, GetId(), <a class="code" href="classwx_point.html" title="A wxPoint is a useful data structure for graphics operations.">wxPoint</a>(...));
    <span class="keyword">event</span>.SetEventObject(<span class="keyword">this</span>);
    ProcessWindowEvent(event);
}
</pre></div><h2><a class="anchor" name="overview_events_misc">
Miscellaneous Notes</a></h2>
<h3><a class="anchor" name="overview_events_virtual">
Event Handlers vs Virtual Methods</a></h3>
It may be noted that wxWidgets' event processing system implements something close to virtual methods in normal C++ in spirit: both of these mechanisms allow you to alter the behaviour of the base class by defining the event handling functions in the derived classes.<p>
There is however an important difference between the two mechanisms when you want to invoke the default behaviour, as implemented by the base class, from a derived class handler. With the virtual functions, you need to call the base class function directly and you can do it either in the beginning of the derived class handler function (to post-process the event) or at its end (to pre-process the event). With the event handlers, you only have the option of pre-processing the events and in order to still let the default behaviour happen you must call <a class="el" href="classwx_event.html#98eb20b76106f9a933c2eb3ee119f66c" title="This method can be used inside an event handler to control whether further event...">wxEvent::Skip()</a> and <em>not</em> call the base class event handler directly. In fact, the event handler probably doesn't even exist in the base class as the default behaviour is often implemented in platform-specific code by the underlying toolkit or OS itself. But even if it does exist at wxWidgets level, it should never be called directly as the event handlers are not part of wxWidgets API and should never be called directly.<h3><a class="anchor" name="overview_events_prog">
User Generated Events vs Programmatically Generated Events</a></h3>
While generically wxEvents can be generated both by user actions (e.g., resize of a <a class="el" href="classwx_window.html" title="wxWindow is the base class for all windows and represents any visible object om screen...">wxWindow</a>) and by calls to functions (e.g., <a class="el" href="classwx_window.html#180312d5ad4a4a5ad805b8d52d67a74e" title="Sets the size of the window in pixels.">wxWindow::SetSize</a>), wxWidgets controls normally send wxCommandEvent-derived events only for the user-generated events. The only <b>exceptions</b> to this rule are:<p>
<ul>
<li><a class="el" href="classwx_book_ctrl_base.html#0fe8e0f8fe5d4036e9d23cdea5698978" title="Adds a new page.">wxNotebook::AddPage</a>: No event-free alternatives </li>
<li><a class="el" href="classwx_book_ctrl_base.html#8b5b18fbf0281e99d227e574b5ffc1ac" title="Cycles through the tabs.">wxNotebook::AdvanceSelection</a>: No event-free alternatives </li>
<li><a class="el" href="classwx_book_ctrl_base.html#7cbc19f60daf15af7019de20561b29f4" title="Deletes the specified page, and the associated window.">wxNotebook::DeletePage</a>: No event-free alternatives </li>
<li><a class="el" href="classwx_book_ctrl_base.html#522ca472343a07a262de92348e3f2d2c" title="Sets the selection for the given page, returning the previous selection.">wxNotebook::SetSelection</a>: Use <a class="el" href="classwx_book_ctrl_base.html#b938512b16be50849c1c4888ffa6aa29" title="Changes the selection for the given page, returning the previous selection.">wxNotebook::ChangeSelection</a> instead, as <a class="el" href="classwx_book_ctrl_base.html#522ca472343a07a262de92348e3f2d2c" title="Sets the selection for the given page, returning the previous selection.">wxNotebook::SetSelection</a> is deprecated </li>
<li><a class="el" href="classwx_tree_ctrl.html#53a2292e2b7b6c13ba3e2d542d8bc1d2" title="Deletes the specified item.">wxTreeCtrl::Delete</a>: No event-free alternatives </li>
<li><a class="el" href="classwx_tree_ctrl.html#76de2019d0fcc73f4c302dff5d392c66" title="Deletes all items in the control.">wxTreeCtrl::DeleteAllItems</a>: No event-free alternatives </li>
<li><a class="el" href="classwx_tree_ctrl.html#4e926a212f0bcf81e473f10dd8311478" title="Starts editing the label of the given item.">wxTreeCtrl::EditLabel</a>: No event-free alternatives </li>
<li>All <a class="el" href="classwx_text_ctrl.html" title="A text control allows text to be displayed and edited.">wxTextCtrl</a> methods</li>
</ul>
<a class="el" href="classwx_text_entry.html#8c52ab71f51c8f80556c2c8e763cbca1" title="Sets the new text control value.">wxTextCtrl::ChangeValue</a> can be used instead of <a class="el" href="classwx_text_entry.html#90f876b2dd83ba5c97ba0c193b386e9f" title="Sets the new text control value.">wxTextCtrl::SetValue</a> but the other functions, such as <a class="el" href="classwx_text_entry.html#1fb3ac76d270b2c64cff595497815f8d" title="Replaces the text starting at the first position up to (but not including) the character...">wxTextCtrl::Replace</a> or <a class="el" href="classwx_text_entry.html#a1b9419f95878c44234ff812b528c17b" title="Writes the text into the text control at the current insertion position.">wxTextCtrl::WriteText</a> don't have event-free equivalents.<h3><a class="anchor" name="overview_events_pluggable">
Pluggable Event Handlers</a></h3>
<em>TODO: Probably deprecated, Bind() provides a better way to do this</em><p>
In fact, you don't have to derive a new class from a window class if you don't want to. You can derive a new class from <a class="el" href="classwx_evt_handler.html" title="A class that can handle events from the windowing system.">wxEvtHandler</a> instead, defining the appropriate event table, and then call <a class="el" href="classwx_window.html#f6c84b7679183b377ba27a52a2f708b4" title="Sets the event handler for this window.">wxWindow::SetEventHandler</a> (or, preferably, <a class="el" href="classwx_window.html#398c11ab9af7956067a964f560d1978c" title="Pushes this event handler onto the event stack for the window.">wxWindow::PushEventHandler</a>) to make this event handler the object that responds to events. This way, you can avoid a lot of class derivation, and use instances of the same event handler class (but different objects as the same event handler object shouldn't be used more than once) to handle events from instances of different widget classes.<p>
If you ever have to call a window's event handler manually, use the GetEventHandler function to retrieve the window's event handler and use that to call the member function. By default, GetEventHandler returns a pointer to the window itself unless an application has redirected event handling using SetEventHandler or PushEventHandler.<p>
One use of PushEventHandler is to temporarily or permanently change the behaviour of the GUI. For example, you might want to invoke a dialog editor in your application that changes aspects of dialog boxes. You can grab all the input for an existing dialog box, and edit it 'in situ', before restoring its behaviour to normal. So even if the application has derived new classes to customize behaviour, your utility can indulge in a spot of body-snatching. It could be a useful technique for on-line tutorials, too, where you take a user through a serious of steps and don't want them to diverge from the lesson. Here, you can examine the events coming from buttons and windows, and if acceptable, pass them through to the original event handler. Use PushEventHandler/PopEventHandler to form a chain of event handlers, where each handler processes a different range of events independently from the other handlers.<h3><a class="anchor" name="overview_events_winid">
Window Identifiers</a></h3>
Window identifiers are integers, and are used to uniquely determine window identity in the event system (though you can use it for other purposes). In fact, identifiers do not need to be unique across your entire application as long they are unique within the particular context you're interested in, such as a frame and its children. You may use the <code>wxID_OK</code> identifier, for example, on any number of dialogs as long as you don't have several within the same dialog.<p>
If you pass <code>wxID_ANY</code> to a window constructor, an identifier will be generated for you automatically by wxWidgets. This is useful when you don't care about the exact identifier either because you're not going to process the events from the control being created or because you process the events from all controls in one place (in which case you should specify <code>wxID_ANY</code> in the event table or <a class="el" href="classwx_evt_handler.html#84b1e446053bda8f76f13336839e8b64" title="Binds the given function, functor or method dynamically with the event.">wxEvtHandler::Bind</a> call as well). The automatically generated identifiers are always negative and so will never conflict with the user-specified identifiers which must be always positive.<p>
See <a class="el" href="page_stdevtid.html">Standard event identifiers</a> for the list of standard identifiers available. You can use wxID_HIGHEST to determine the number above which it is safe to define your own identifiers. Or, you can use identifiers below wxID_LOWEST. Finally, you can allocate identifiers dynamically using <a class="el" href="group__group__funcmacro__misc.html#gef162e1ba5d17a839b2f7912424bc822">wxNewId()</a> function too. If you use <a class="el" href="group__group__funcmacro__misc.html#gef162e1ba5d17a839b2f7912424bc822">wxNewId()</a> consistently in your application, you can be sure that your identifiers don't conflict accidentally.<h3><a class="anchor" name="overview_events_custom_generic">
Generic Event Table Macros</a></h3>
<table class="doctable" border="1" cellspacing="0" cellpadding="3">
<tr>
<td>EVT_CUSTOM(event, id, func) </td><td>Allows you to add a custom event table entry by specifying the event identifier (such as wxEVT_SIZE), the window identifier, and a member function to call. </td></tr>
<tr>
<td>EVT_CUSTOM_RANGE(event, id1, id2, func) </td><td>The same as EVT_CUSTOM, but responds to a range of window identifiers. </td></tr>
<tr>
<td>EVT_COMMAND(id, event, func) </td><td>The same as EVT_CUSTOM, but expects a member function with a <a class="el" href="classwx_command_event.html" title="This event class contains information about command events, which originate from...">wxCommandEvent</a> argument. </td></tr>
<tr>
<td>EVT_COMMAND_RANGE(id1, id2, event, func) </td><td>The same as EVT_CUSTOM_RANGE, but expects a member function with a <a class="el" href="classwx_command_event.html" title="This event class contains information about command events, which originate from...">wxCommandEvent</a> argument. </td></tr>
<tr>
<td>EVT_NOTIFY(event, id, func) </td><td>The same as EVT_CUSTOM, but expects a member function with a <a class="el" href="classwx_notify_event.html" title="This class is not used by the event handlers by itself, but is a base class for other...">wxNotifyEvent</a> argument. </td></tr>
<tr>
<td>EVT_NOTIFY_RANGE(event, id1, id2, func) </td><td>The same as EVT_CUSTOM_RANGE, but expects a member function with a <a class="el" href="classwx_notify_event.html" title="This class is not used by the event handlers by itself, but is a base class for other...">wxNotifyEvent</a> argument. </td></tr>
</table>
<h3><a class="anchor" name="overview_events_list">
List of wxWidgets events</a></h3>
For the full list of event classes, please see the <a class="el" href="group__group__class__events.html">event classes group page</a>. </div>
<!-- ******************************************************* -->
<!--             Standard wxWidgets footer                   -->

<!-- NOTE: <br/> must go inside <p> but <hr/> must go outside -->
<p><br/></p><hr/>

<table width="100%" border="0">
<tr>
    <td align="left">
        <a href="http://www.wxwidgets.org" style="margin-left: 0px">
            <img src="powered-by-wxwidgets.png" alt="wxWidgets logo" border="0"/>
        </a>
    </td>
    <td valign="middle" align="center"><p class="footer">Page generated <tt>Fri Sep 4 06:57:19 2009</tt> by <a href="http://www.doxygen.org">Doxygen</a> 1.5.8</p></td>
    <td valign="middle" align="right"><p>[ <a href="#top" class="top">top</a> ]</p></td>
</tr>
</table>

<script src="wxwidgets.js" type="text/javascript"></script>

</body>
</html>

<!-- ***************************************************** -->
<!--         End of wxWidgets standard footer              -->
